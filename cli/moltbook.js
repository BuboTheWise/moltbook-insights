#!/usr/bin/env node\nimport { Command } from 'commander';\nimport chalk from 'chalk';\nimport fs from 'fs/promises';\n\nconst program = new Command()\n  .name('moltbook')\n  .description('Moltbook Insights CLI - Amplified')\n  .version('1.2.0')\n  .option('-k, --api-key &lt;key&gt;', 'API key')\n  .option('--json', 'JSON output only');\n\nconst apiKey = process.env.MOLTBOOK_API_KEY;\n\nif (!apiKey) {\n  console.error(chalk.red('‚ùå API key required: MOLTBOOK_API_KEY env or --api-key'));\n  process.exit(1);\n}\n\nconsole.log(chalk.green(`üîë API Key loaded: ${apiKey.slice(0,8)}...`));\n\nconst baseURL = 'https://www.moltbook.com/api/v1';\n\nasync function callApi(path, options = {}) {\n  const url = `${baseURL}${path}`;\n  const headers = {\n    'Authorization': `Bearer ${apiKey}`,\n    'Content-Type': 'application/json',\n    ...options.headers,\n  };\n\n  const res = await fetch(url, { headers, ...options });\n  if (!res.ok) {\n    const err = await res.text();\n    throw new Error(chalk.red(`API Error ${res.status}: ${err.slice(0,200)}`));\n  }\n  return res.json();\n}\n\n// ... existing commands (posts, top, search, replies, agents) ...\n\n// Agent search/profile\nprogram\n  .command('agent &lt;query&gt;')\n  .description('Search agent posts')\n  .option('-l, --limit &lt;num&gt;', 'Limit', '10')\n  .action(async (query, opts) =&gt; {\n    const data = await callApi(`/search?q=${encodeURIComponent(query)}`);\n    const agentPosts = data.results.filter(r =&gt; r.author.name.toLowerCase().includes(query.toLowerCase()));\n    if (program.opts().json) {\n      console.log(JSON.stringify(agentPosts, null, 2));\n    } else {\n      console.log(chalk.magenta(`ü§ñ Agent '${query}' Posts:`));\n      agentPosts.slice(0, opts.limit).forEach(p =&gt; {\n        console.log(`${p.title} (${p.upvotes} üëç | ${p.created_at.slice(0,10)})`);\n      });\n    }\n  });\n\n// Opps filter\nprogram\n  .command('opps')\n  .description('Wise opps filter')\n  .option('--min &lt;num&gt;', 'Min upvotes', '100')\n  .option('--tags &lt;csv&gt;', 'Tags CSV', 'build,collab,opportunity,help')\n  .action(async (cmd) =&gt; {\n    const tags = cmd.tags.split(',');\n    const data = await callApi('/posts?sort=likes&limit=50');\n    const opps = data.posts.filter(p =&gt; {\n      const score = p.upvotes;\n      const match = tags.some(t =&gt; (p.content || p.title || '').toLowerCase().includes(t.toLowerCase()));\n      return score &gt;= cmd.min &amp;&amp; match;\n    });\n    if (program.opts().json) {\n      console.log(JSON.stringify(opps, null, 2));\n    } else {\n      console.log(chalk.green(`üéØ Opps (min ${cmd.min}, tags ${cmd.tags}): ${opps.length}`));\n      opps.slice(0,10).forEach(p =&gt; console.log(`${p.title} by ${p.author.name} (${p.upvotes} üëç)`));\n    }\n  });\n\n// Post composer/scheduler\nprogram\n  .command('compose')\n  .description('Interactive composer')\n  .action(async () =&gt; {\n    console.log(chalk.cyan('Content (multi-line, end with . on line):'));\n    let content = '';\n    const process = require('process');\n    const readline = require('readline');\n    const rl = readline.createInterface({\n      input: process.stdin,\n      output: process.stdout,\n      terminal: false\n    });\n    for await (const line of rl) {\n      if (line.trim() === '.') break;\n      content += line + '\\n';\n    }\n    rl.close();\n    // Pipe to post\n    await program.parseAsync(['', '', 'post', content.trim()]);\n  });\n\nprogram\n  .command('post &lt;content&gt;')\n  .description('Post')\n  .option('--schedule &lt;iso&gt;', 'Schedule ISO (stub json)')\n  .action(async (content, cmd) =&gt; {\n    if (cmd.schedule) {\n      let scheduled = [];\n      try {\n        scheduled = JSON.parse(await fs.readFile('./scheduled-posts.json', 'utf8'));\n      } catch {}\n      scheduled.push({content, schedule: cmd.schedule});\n      await fs.writeFile('./scheduled-posts.json', JSON.stringify(scheduled, null, 2));\n      console.log(chalk.yellow('‚è∞ Scheduled saved.'));\n      return;\n    }\n    const data = await callApi('/posts', {\n      method: 'POST',\n      body: JSON.stringify({content})\n    });\n    console.log(chalk.green('‚úÖ Posted'), data);\n  });\n\n// Obsidian export\nprogram\n  .command('obsidian-export &lt;dir&gt;')\n  .description('Export to Obsidian vault')\n  .action(async (dir) =&gt; {\n    const data = await callApi('/posts?sort=likes&limit=50');\n    await fs.mkdir(dir, {recursive: true});\n    for (const p of data.posts) {\n      const md = `---\ntitle: ${p.title}\nauthor: ${p.author.name}\nupvotes: ${p.upvotes}\ndate: ${p.created_at}\nsubmolt: ${p.submolt.name}\n---\n\n${p.content.replace(/\\n/g, '\\n\\n')}`;\n      await fs.writeFile(`${dir}/${p.id.slice(0,8)}.md`, md);\n    }\n    console.log(chalk.green(`üì± Exported ${data.posts.length} posts to ${dir}`));\n  });\n\nprogram.parse(process.argv);\n\nif (process.argv.length &lt;= 2) {\n  program.help();\n}